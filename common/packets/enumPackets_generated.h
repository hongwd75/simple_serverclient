// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENUMPACKETS_NETWORKMESSAGE_H_
#define FLATBUFFERS_GENERATED_ENUMPACKETS_NETWORKMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");


namespace NetworkMessage {

enum ServerPackets : uint16_t {
  ServerPackets_SC_LoginAns = 1,
  ServerPackets_SC_AccountInfo = 2,
  ServerPackets_SC_WorldEnterNotify = 3,
  ServerPackets_SC_CreatePlayer = 4,
  ServerPackets_SC_CreatePlayers = 5,
  ServerPackets_SC_RemovePlayer = 6,
  ServerPackets_SC_UpdatePosition = 7,
  ServerPackets_SC_PlayerUpdate = 8,
  ServerPackets_MIN = ServerPackets_SC_LoginAns,
  ServerPackets_MAX = ServerPackets_SC_PlayerUpdate
};

inline const ServerPackets (&EnumValuesServerPackets())[8] {
  static const ServerPackets values[] = {
    ServerPackets_SC_LoginAns,
    ServerPackets_SC_AccountInfo,
    ServerPackets_SC_WorldEnterNotify,
    ServerPackets_SC_CreatePlayer,
    ServerPackets_SC_CreatePlayers,
    ServerPackets_SC_RemovePlayer,
    ServerPackets_SC_UpdatePosition,
    ServerPackets_SC_PlayerUpdate
  };
  return values;
}

inline const char * const *EnumNamesServerPackets() {
  static const char * const names[9] = {
    "SC_LoginAns",
    "SC_AccountInfo",
    "SC_WorldEnterNotify",
    "SC_CreatePlayer",
    "SC_CreatePlayers",
    "SC_RemovePlayer",
    "SC_UpdatePosition",
    "SC_PlayerUpdate",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerPackets(ServerPackets e) {
  if (::flatbuffers::IsOutRange(e, ServerPackets_SC_LoginAns, ServerPackets_SC_PlayerUpdate)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ServerPackets_SC_LoginAns);
  return EnumNamesServerPackets()[index];
}

enum ClientPackets : uint16_t {
  ClientPackets_CS_LoginReq = 1,
  ClientPackets_CS_WorldJoinReq = 2,
  ClientPackets_CS_UpdatePosition = 3,
  ClientPackets_MIN = ClientPackets_CS_LoginReq,
  ClientPackets_MAX = ClientPackets_CS_UpdatePosition
};

inline const ClientPackets (&EnumValuesClientPackets())[3] {
  static const ClientPackets values[] = {
    ClientPackets_CS_LoginReq,
    ClientPackets_CS_WorldJoinReq,
    ClientPackets_CS_UpdatePosition
  };
  return values;
}

inline const char * const *EnumNamesClientPackets() {
  static const char * const names[4] = {
    "CS_LoginReq",
    "CS_WorldJoinReq",
    "CS_UpdatePosition",
    nullptr
  };
  return names;
}

inline const char *EnumNameClientPackets(ClientPackets e) {
  if (::flatbuffers::IsOutRange(e, ClientPackets_CS_LoginReq, ClientPackets_CS_UpdatePosition)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ClientPackets_CS_LoginReq);
  return EnumNamesClientPackets()[index];
}

}  // namespace NetworkMessage

#endif  // FLATBUFFERS_GENERATED_ENUMPACKETS_NETWORKMESSAGE_H_
