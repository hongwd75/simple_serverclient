// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKMESSAGE_H_
#define FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "enumPackets_generated.h"
#include "structs_generated.h"

namespace NetworkMessage {

struct CS_LoginReq;
struct CS_LoginReqBuilder;
struct CS_LoginReq_FBS;

struct CS_WorldJoinReq;
struct CS_WorldJoinReqBuilder;
struct CS_WorldJoinReq_FBS;

struct CS_UpdatePosition;
struct CS_UpdatePositionBuilder;
struct CS_UpdatePosition_FBS;

struct SC_LoginAns;
struct SC_LoginAnsBuilder;
struct SC_LoginAns_FBS;

struct SC_AccountInfo;
struct SC_AccountInfoBuilder;
struct SC_AccountInfo_FBS;

struct SC_WorldEnterNotify;
struct SC_WorldEnterNotifyBuilder;
struct SC_WorldEnterNotify_FBS;

struct SC_CreatePlayer;
struct SC_CreatePlayerBuilder;
struct SC_CreatePlayer_FBS;

struct SC_CreatePlayers;
struct SC_CreatePlayersBuilder;
struct SC_CreatePlayers_FBS;

struct SC_RemovePlayer;
struct SC_RemovePlayerBuilder;
struct SC_RemovePlayer_FBS;

struct SC_UpdatePosition;
struct SC_UpdatePositionBuilder;
struct SC_UpdatePosition_FBS;

struct SC_PlayerUpdate;
struct SC_PlayerUpdateBuilder;
struct SC_PlayerUpdate_FBS;

struct PacketWrapper;
struct PacketWrapperBuilder;
struct PacketWrapper_FBS;

bool operator==(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs);
bool operator!=(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs);
bool operator==(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs);
bool operator!=(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs);
bool operator==(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs);
bool operator!=(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs);
bool operator==(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs);
bool operator!=(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs);
bool operator==(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs);
bool operator!=(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs);
bool operator==(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs);
bool operator!=(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs);
bool operator==(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs);
bool operator!=(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs);
bool operator==(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs);
bool operator!=(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs);
bool operator==(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs);
bool operator!=(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs);
bool operator==(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs);
bool operator!=(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs);
bool operator==(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs);
bool operator!=(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs);
bool operator==(const PacketWrapper_FBS &lhs, const PacketWrapper_FBS &rhs);
bool operator!=(const PacketWrapper_FBS &lhs, const PacketWrapper_FBS &rhs);

struct CS_LoginReq_FBS : public ::flatbuffers::NativeTable {
  typedef CS_LoginReq TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_LoginReq_FBS";
  }
  std::string id{};
  std::string pwd{};
};

struct CS_LoginReq FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CS_LoginReq_FBS NativeTableType;
  typedef CS_LoginReqBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_LoginReq";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PWD = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *pwd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PWD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_PWD) &&
           verifier.VerifyString(pwd()) &&
           verifier.EndTable();
  }
  CS_LoginReq_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CS_LoginReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CS_LoginReq> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CS_LoginReqBuilder {
  typedef CS_LoginReq Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(CS_LoginReq::VT_ID, id);
  }
  void add_pwd(::flatbuffers::Offset<::flatbuffers::String> pwd) {
    fbb_.AddOffset(CS_LoginReq::VT_PWD, pwd);
  }
  explicit CS_LoginReqBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CS_LoginReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CS_LoginReq>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReq(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pwd = 0) {
  CS_LoginReqBuilder builder_(_fbb);
  builder_.add_pwd(pwd);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReqDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *pwd = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto pwd__ = pwd ? _fbb.CreateString(pwd) : 0;
  return NetworkMessage::CreateCS_LoginReq(
      _fbb,
      id__,
      pwd__);
}

::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CS_WorldJoinReq_FBS : public ::flatbuffers::NativeTable {
  typedef CS_WorldJoinReq TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_WorldJoinReq_FBS";
  }
  int32_t gate = 0;
};

struct CS_WorldJoinReq FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CS_WorldJoinReq_FBS NativeTableType;
  typedef CS_WorldJoinReqBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_WorldJoinReq";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GATE = 4
  };
  int32_t gate() const {
    return GetField<int32_t>(VT_GATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GATE, 4) &&
           verifier.EndTable();
  }
  CS_WorldJoinReq_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CS_WorldJoinReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CS_WorldJoinReq> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CS_WorldJoinReqBuilder {
  typedef CS_WorldJoinReq Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gate(int32_t gate) {
    fbb_.AddElement<int32_t>(CS_WorldJoinReq::VT_GATE, gate, 0);
  }
  explicit CS_WorldJoinReqBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CS_WorldJoinReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CS_WorldJoinReq>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CS_WorldJoinReq> CreateCS_WorldJoinReq(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t gate = 0) {
  CS_WorldJoinReqBuilder builder_(_fbb);
  builder_.add_gate(gate);
  return builder_.Finish();
}

::flatbuffers::Offset<CS_WorldJoinReq> CreateCS_WorldJoinReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CS_UpdatePosition_FBS : public ::flatbuffers::NativeTable {
  typedef CS_UpdatePosition TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_UpdatePosition_FBS";
  }
  int32_t sessionid = 0;
  int32_t head = 0;
  std::shared_ptr<NetworkMessage::Vector3> position{};
  CS_UpdatePosition_FBS() = default;
  CS_UpdatePosition_FBS(const CS_UpdatePosition_FBS &o);
  CS_UpdatePosition_FBS(CS_UpdatePosition_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  CS_UpdatePosition_FBS &operator=(CS_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct CS_UpdatePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CS_UpdatePosition_FBS NativeTableType;
  typedef CS_UpdatePositionBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.CS_UpdatePosition";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4,
    VT_HEAD = 6,
    VT_POSITION = 8
  };
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  int32_t head() const {
    return GetField<int32_t>(VT_HEAD, 0);
  }
  const NetworkMessage::Vector3 *position() const {
    return GetStruct<const NetworkMessage::Vector3 *>(VT_POSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyField<int32_t>(verifier, VT_HEAD, 4) &&
           VerifyField<NetworkMessage::Vector3>(verifier, VT_POSITION, 4) &&
           verifier.EndTable();
  }
  CS_UpdatePosition_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CS_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CS_UpdatePosition> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CS_UpdatePositionBuilder {
  typedef CS_UpdatePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(CS_UpdatePosition::VT_SESSIONID, sessionid, 0);
  }
  void add_head(int32_t head) {
    fbb_.AddElement<int32_t>(CS_UpdatePosition::VT_HEAD, head, 0);
  }
  void add_position(const NetworkMessage::Vector3 *position) {
    fbb_.AddStruct(CS_UpdatePosition::VT_POSITION, position);
  }
  explicit CS_UpdatePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CS_UpdatePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CS_UpdatePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CS_UpdatePosition> CreateCS_UpdatePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sessionid = 0,
    int32_t head = 0,
    const NetworkMessage::Vector3 *position = nullptr) {
  CS_UpdatePositionBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_head(head);
  builder_.add_sessionid(sessionid);
  return builder_.Finish();
}

::flatbuffers::Offset<CS_UpdatePosition> CreateCS_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_LoginAns_FBS : public ::flatbuffers::NativeTable {
  typedef SC_LoginAns TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_LoginAns_FBS";
  }
  int32_t errorcode = 0;
  int32_t sessionid = 0;
  std::string nickname{};
};

/////////////////////////////////////////////////////////
struct SC_LoginAns FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_LoginAns_FBS NativeTableType;
  typedef SC_LoginAnsBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_LoginAns";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4,
    VT_SESSIONID = 6,
    VT_NICKNAME = 8
  };
  int32_t errorcode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE, 4) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           verifier.EndTable();
  }
  SC_LoginAns_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_LoginAns_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_LoginAns> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_LoginAnsBuilder {
  typedef SC_LoginAns Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(int32_t errorcode) {
    fbb_.AddElement<int32_t>(SC_LoginAns::VT_ERRORCODE, errorcode, 0);
  }
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_LoginAns::VT_SESSIONID, sessionid, 0);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(SC_LoginAns::VT_NICKNAME, nickname);
  }
  explicit SC_LoginAnsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_LoginAns> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_LoginAns>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAns(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorcode = 0,
    int32_t sessionid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0) {
  SC_LoginAnsBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_sessionid(sessionid);
  builder_.add_errorcode(errorcode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAnsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorcode = 0,
    int32_t sessionid = 0,
    const char *nickname = nullptr) {
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  return NetworkMessage::CreateSC_LoginAns(
      _fbb,
      errorcode,
      sessionid,
      nickname__);
}

::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAns(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_AccountInfo_FBS : public ::flatbuffers::NativeTable {
  typedef SC_AccountInfo TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_AccountInfo_FBS";
  }
  int32_t chartype = 0;
};

struct SC_AccountInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_AccountInfo_FBS NativeTableType;
  typedef SC_AccountInfoBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_AccountInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARTYPE = 4
  };
  int32_t chartype() const {
    return GetField<int32_t>(VT_CHARTYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARTYPE, 4) &&
           verifier.EndTable();
  }
  SC_AccountInfo_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_AccountInfo_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_AccountInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_AccountInfoBuilder {
  typedef SC_AccountInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chartype(int32_t chartype) {
    fbb_.AddElement<int32_t>(SC_AccountInfo::VT_CHARTYPE, chartype, 0);
  }
  explicit SC_AccountInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_AccountInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_AccountInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_AccountInfo> CreateSC_AccountInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t chartype = 0) {
  SC_AccountInfoBuilder builder_(_fbb);
  builder_.add_chartype(chartype);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_AccountInfo> CreateSC_AccountInfo(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_WorldEnterNotify_FBS : public ::flatbuffers::NativeTable {
  typedef SC_WorldEnterNotify TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_WorldEnterNotify_FBS";
  }
  int32_t zoneid = 0;
};

struct SC_WorldEnterNotify FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_WorldEnterNotify_FBS NativeTableType;
  typedef SC_WorldEnterNotifyBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_WorldEnterNotify";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ZONEID = 4
  };
  int32_t zoneid() const {
    return GetField<int32_t>(VT_ZONEID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ZONEID, 4) &&
           verifier.EndTable();
  }
  SC_WorldEnterNotify_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_WorldEnterNotify> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_WorldEnterNotifyBuilder {
  typedef SC_WorldEnterNotify Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_zoneid(int32_t zoneid) {
    fbb_.AddElement<int32_t>(SC_WorldEnterNotify::VT_ZONEID, zoneid, 0);
  }
  explicit SC_WorldEnterNotifyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_WorldEnterNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_WorldEnterNotify>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_WorldEnterNotify> CreateSC_WorldEnterNotify(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t zoneid = 0) {
  SC_WorldEnterNotifyBuilder builder_(_fbb);
  builder_.add_zoneid(zoneid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_WorldEnterNotify> CreateSC_WorldEnterNotify(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_CreatePlayer_FBS : public ::flatbuffers::NativeTable {
  typedef SC_CreatePlayer TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayer_FBS";
  }
  std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS> player{};
  SC_CreatePlayer_FBS() = default;
  SC_CreatePlayer_FBS(const SC_CreatePlayer_FBS &o);
  SC_CreatePlayer_FBS(SC_CreatePlayer_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_CreatePlayer_FBS &operator=(SC_CreatePlayer_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_CreatePlayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_CreatePlayer_FBS NativeTableType;
  typedef SC_CreatePlayerBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayer";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER = 4
  };
  const NetworkMessage::CreatePlayerInfo *player() const {
    return GetPointer<const NetworkMessage::CreatePlayerInfo *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           verifier.EndTable();
  }
  SC_CreatePlayer_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_CreatePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_CreatePlayer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_CreatePlayerBuilder {
  typedef SC_CreatePlayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player(::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo> player) {
    fbb_.AddOffset(SC_CreatePlayer::VT_PLAYER, player);
  }
  explicit SC_CreatePlayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_CreatePlayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_CreatePlayer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_CreatePlayer> CreateSC_CreatePlayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo> player = 0) {
  SC_CreatePlayerBuilder builder_(_fbb);
  builder_.add_player(player);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_CreatePlayer> CreateSC_CreatePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_CreatePlayers_FBS : public ::flatbuffers::NativeTable {
  typedef SC_CreatePlayers TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayers_FBS";
  }
  std::vector<std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS>> player{};
  SC_CreatePlayers_FBS() = default;
  SC_CreatePlayers_FBS(const SC_CreatePlayers_FBS &o);
  SC_CreatePlayers_FBS(SC_CreatePlayers_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_CreatePlayers_FBS &operator=(SC_CreatePlayers_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_CreatePlayers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_CreatePlayers_FBS NativeTableType;
  typedef SC_CreatePlayersBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_CreatePlayers";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> *player() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyVector(player()) &&
           verifier.VerifyVectorOfTables(player()) &&
           verifier.EndTable();
  }
  SC_CreatePlayers_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_CreatePlayers_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_CreatePlayers> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_CreatePlayersBuilder {
  typedef SC_CreatePlayers Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>>> player) {
    fbb_.AddOffset(SC_CreatePlayers::VT_PLAYER, player);
  }
  explicit SC_CreatePlayersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_CreatePlayers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_CreatePlayers>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayers(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>>> player = 0) {
  SC_CreatePlayersBuilder builder_(_fbb);
  builder_.add_player(player);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> *player = nullptr) {
  auto player__ = player ? _fbb.CreateVector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>>(*player) : 0;
  return NetworkMessage::CreateSC_CreatePlayers(
      _fbb,
      player__);
}

::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayers(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_RemovePlayer_FBS : public ::flatbuffers::NativeTable {
  typedef SC_RemovePlayer TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_RemovePlayer_FBS";
  }
  int32_t sessionid = 0;
};

struct SC_RemovePlayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_RemovePlayer_FBS NativeTableType;
  typedef SC_RemovePlayerBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_RemovePlayer";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4
  };
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           verifier.EndTable();
  }
  SC_RemovePlayer_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_RemovePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_RemovePlayer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_RemovePlayerBuilder {
  typedef SC_RemovePlayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_RemovePlayer::VT_SESSIONID, sessionid, 0);
  }
  explicit SC_RemovePlayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_RemovePlayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_RemovePlayer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_RemovePlayer> CreateSC_RemovePlayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sessionid = 0) {
  SC_RemovePlayerBuilder builder_(_fbb);
  builder_.add_sessionid(sessionid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_RemovePlayer> CreateSC_RemovePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_UpdatePosition_FBS : public ::flatbuffers::NativeTable {
  typedef SC_UpdatePosition TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_UpdatePosition_FBS";
  }
  int32_t sessionid = 0;
  int32_t head = 0;
  std::shared_ptr<NetworkMessage::Vector3> position{};
  SC_UpdatePosition_FBS() = default;
  SC_UpdatePosition_FBS(const SC_UpdatePosition_FBS &o);
  SC_UpdatePosition_FBS(SC_UpdatePosition_FBS&&) FLATBUFFERS_NOEXCEPT = default;
  SC_UpdatePosition_FBS &operator=(SC_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT;
};

struct SC_UpdatePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_UpdatePosition_FBS NativeTableType;
  typedef SC_UpdatePositionBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_UpdatePosition";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4,
    VT_HEAD = 6,
    VT_POSITION = 8
  };
  int32_t sessionid() const {
    return GetField<int32_t>(VT_SESSIONID, 0);
  }
  int32_t head() const {
    return GetField<int32_t>(VT_HEAD, 0);
  }
  const NetworkMessage::Vector3 *position() const {
    return GetStruct<const NetworkMessage::Vector3 *>(VT_POSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SESSIONID, 4) &&
           VerifyField<int32_t>(verifier, VT_HEAD, 4) &&
           VerifyField<NetworkMessage::Vector3>(verifier, VT_POSITION, 4) &&
           verifier.EndTable();
  }
  SC_UpdatePosition_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_UpdatePosition> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_UpdatePositionBuilder {
  typedef SC_UpdatePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionid(int32_t sessionid) {
    fbb_.AddElement<int32_t>(SC_UpdatePosition::VT_SESSIONID, sessionid, 0);
  }
  void add_head(int32_t head) {
    fbb_.AddElement<int32_t>(SC_UpdatePosition::VT_HEAD, head, 0);
  }
  void add_position(const NetworkMessage::Vector3 *position) {
    fbb_.AddStruct(SC_UpdatePosition::VT_POSITION, position);
  }
  explicit SC_UpdatePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_UpdatePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_UpdatePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_UpdatePosition> CreateSC_UpdatePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sessionid = 0,
    int32_t head = 0,
    const NetworkMessage::Vector3 *position = nullptr) {
  SC_UpdatePositionBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_head(head);
  builder_.add_sessionid(sessionid);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_UpdatePosition> CreateSC_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SC_PlayerUpdate_FBS : public ::flatbuffers::NativeTable {
  typedef SC_PlayerUpdate TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_PlayerUpdate_FBS";
  }
  int32_t head = 0;
  int32_t health = 0;
  int32_t state = 0;
};

struct SC_PlayerUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_PlayerUpdate_FBS NativeTableType;
  typedef SC_PlayerUpdateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.SC_PlayerUpdate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEAD = 4,
    VT_HEALTH = 6,
    VT_STATE = 8
  };
  int32_t head() const {
    return GetField<int32_t>(VT_HEAD, 0);
  }
  int32_t health() const {
    return GetField<int32_t>(VT_HEALTH, 0);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEAD, 4) &&
           VerifyField<int32_t>(verifier, VT_HEALTH, 4) &&
           VerifyField<int32_t>(verifier, VT_STATE, 4) &&
           verifier.EndTable();
  }
  SC_PlayerUpdate_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SC_PlayerUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SC_PlayerUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SC_PlayerUpdateBuilder {
  typedef SC_PlayerUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_head(int32_t head) {
    fbb_.AddElement<int32_t>(SC_PlayerUpdate::VT_HEAD, head, 0);
  }
  void add_health(int32_t health) {
    fbb_.AddElement<int32_t>(SC_PlayerUpdate::VT_HEALTH, health, 0);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(SC_PlayerUpdate::VT_STATE, state, 0);
  }
  explicit SC_PlayerUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_PlayerUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_PlayerUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_PlayerUpdate> CreateSC_PlayerUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t head = 0,
    int32_t health = 0,
    int32_t state = 0) {
  SC_PlayerUpdateBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_health(health);
  builder_.add_head(head);
  return builder_.Finish();
}

::flatbuffers::Offset<SC_PlayerUpdate> CreateSC_PlayerUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PacketWrapper_FBS : public ::flatbuffers::NativeTable {
  typedef PacketWrapper TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.PacketWrapper_FBS";
  }
  uint16_t type = 0;
  std::vector<uint8_t> packet{};
};

struct PacketWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PacketWrapper_FBS NativeTableType;
  typedef PacketWrapperBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "NetworkMessage.PacketWrapper";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PACKET = 6
  };
  uint16_t type() const {
    return GetField<uint16_t>(VT_TYPE, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *packet() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PACKET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TYPE, 2) &&
           VerifyOffset(verifier, VT_PACKET) &&
           verifier.VerifyVector(packet()) &&
           verifier.EndTable();
  }
  PacketWrapper_FBS *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PacketWrapper_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PacketWrapper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PacketWrapper_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PacketWrapperBuilder {
  typedef PacketWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(uint16_t type) {
    fbb_.AddElement<uint16_t>(PacketWrapper::VT_TYPE, type, 0);
  }
  void add_packet(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> packet) {
    fbb_.AddOffset(PacketWrapper::VT_PACKET, packet);
  }
  explicit PacketWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PacketWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PacketWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PacketWrapper> CreatePacketWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> packet = 0) {
  PacketWrapperBuilder builder_(_fbb);
  builder_.add_packet(packet);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PacketWrapper> CreatePacketWrapperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t type = 0,
    const std::vector<uint8_t> *packet = nullptr) {
  auto packet__ = packet ? _fbb.CreateVector<uint8_t>(*packet) : 0;
  return NetworkMessage::CreatePacketWrapper(
      _fbb,
      type,
      packet__);
}

::flatbuffers::Offset<PacketWrapper> CreatePacketWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const PacketWrapper_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.pwd == rhs.pwd);
}

inline bool operator!=(const CS_LoginReq_FBS &lhs, const CS_LoginReq_FBS &rhs) {
    return !(lhs == rhs);
}


inline CS_LoginReq_FBS *CS_LoginReq::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CS_LoginReq_FBS>(new CS_LoginReq_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CS_LoginReq::UnPackTo(CS_LoginReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = pwd(); if (_e) _o->pwd = _e->str(); }
}

inline ::flatbuffers::Offset<CS_LoginReq> CS_LoginReq::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCS_LoginReq(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CS_LoginReq> CreateCS_LoginReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_LoginReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CS_LoginReq_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->id);
  auto _pwd = _o->pwd.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->pwd);
  return NetworkMessage::CreateCS_LoginReq(
      _fbb,
      _id,
      _pwd);
}


inline bool operator==(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs) {
  return
      (lhs.gate == rhs.gate);
}

inline bool operator!=(const CS_WorldJoinReq_FBS &lhs, const CS_WorldJoinReq_FBS &rhs) {
    return !(lhs == rhs);
}


inline CS_WorldJoinReq_FBS *CS_WorldJoinReq::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CS_WorldJoinReq_FBS>(new CS_WorldJoinReq_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CS_WorldJoinReq::UnPackTo(CS_WorldJoinReq_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = gate(); _o->gate = _e; }
}

inline ::flatbuffers::Offset<CS_WorldJoinReq> CS_WorldJoinReq::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCS_WorldJoinReq(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CS_WorldJoinReq> CreateCS_WorldJoinReq(::flatbuffers::FlatBufferBuilder &_fbb, const CS_WorldJoinReq_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CS_WorldJoinReq_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _gate = _o->gate;
  return NetworkMessage::CreateCS_WorldJoinReq(
      _fbb,
      _gate);
}


inline bool operator==(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs) {
  return
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.head == rhs.head) &&
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position));
}

inline bool operator!=(const CS_UpdatePosition_FBS &lhs, const CS_UpdatePosition_FBS &rhs) {
    return !(lhs == rhs);
}


inline CS_UpdatePosition_FBS::CS_UpdatePosition_FBS(const CS_UpdatePosition_FBS &o)
      : sessionid(o.sessionid),
        head(o.head),
        position((o.position) ? new NetworkMessage::Vector3(*o.position) : nullptr) {
}

inline CS_UpdatePosition_FBS &CS_UpdatePosition_FBS::operator=(CS_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(sessionid, o.sessionid);
  std::swap(head, o.head);
  std::swap(position, o.position);
  return *this;
}

inline CS_UpdatePosition_FBS *CS_UpdatePosition::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CS_UpdatePosition_FBS>(new CS_UpdatePosition_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CS_UpdatePosition::UnPackTo(CS_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = head(); _o->head = _e; }
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3>(new NetworkMessage::Vector3(*_e)); }
}

inline ::flatbuffers::Offset<CS_UpdatePosition> CS_UpdatePosition::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCS_UpdatePosition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CS_UpdatePosition> CreateCS_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const CS_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CS_UpdatePosition_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionid = _o->sessionid;
  auto _head = _o->head;
  auto _position = _o->position ? _o->position.get() : nullptr;
  return NetworkMessage::CreateCS_UpdatePosition(
      _fbb,
      _sessionid,
      _head,
      _position);
}


inline bool operator==(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs) {
  return
      (lhs.errorcode == rhs.errorcode) &&
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.nickname == rhs.nickname);
}

inline bool operator!=(const SC_LoginAns_FBS &lhs, const SC_LoginAns_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_LoginAns_FBS *SC_LoginAns::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_LoginAns_FBS>(new SC_LoginAns_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_LoginAns::UnPackTo(SC_LoginAns_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = errorcode(); _o->errorcode = _e; }
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = nickname(); if (_e) _o->nickname = _e->str(); }
}

inline ::flatbuffers::Offset<SC_LoginAns> SC_LoginAns::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_LoginAns(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_LoginAns> CreateSC_LoginAns(::flatbuffers::FlatBufferBuilder &_fbb, const SC_LoginAns_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_LoginAns_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _errorcode = _o->errorcode;
  auto _sessionid = _o->sessionid;
  auto _nickname = _o->nickname.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->nickname);
  return NetworkMessage::CreateSC_LoginAns(
      _fbb,
      _errorcode,
      _sessionid,
      _nickname);
}


inline bool operator==(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs) {
  return
      (lhs.chartype == rhs.chartype);
}

inline bool operator!=(const SC_AccountInfo_FBS &lhs, const SC_AccountInfo_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_AccountInfo_FBS *SC_AccountInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_AccountInfo_FBS>(new SC_AccountInfo_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_AccountInfo::UnPackTo(SC_AccountInfo_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chartype(); _o->chartype = _e; }
}

inline ::flatbuffers::Offset<SC_AccountInfo> SC_AccountInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_AccountInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_AccountInfo> CreateSC_AccountInfo(::flatbuffers::FlatBufferBuilder &_fbb, const SC_AccountInfo_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_AccountInfo_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chartype = _o->chartype;
  return NetworkMessage::CreateSC_AccountInfo(
      _fbb,
      _chartype);
}


inline bool operator==(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs) {
  return
      (lhs.zoneid == rhs.zoneid);
}

inline bool operator!=(const SC_WorldEnterNotify_FBS &lhs, const SC_WorldEnterNotify_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_WorldEnterNotify_FBS *SC_WorldEnterNotify::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_WorldEnterNotify_FBS>(new SC_WorldEnterNotify_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_WorldEnterNotify::UnPackTo(SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = zoneid(); _o->zoneid = _e; }
}

inline ::flatbuffers::Offset<SC_WorldEnterNotify> SC_WorldEnterNotify::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_WorldEnterNotify(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_WorldEnterNotify> CreateSC_WorldEnterNotify(::flatbuffers::FlatBufferBuilder &_fbb, const SC_WorldEnterNotify_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_WorldEnterNotify_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _zoneid = _o->zoneid;
  return NetworkMessage::CreateSC_WorldEnterNotify(
      _fbb,
      _zoneid);
}


inline bool operator==(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs) {
  return
      ((lhs.player == rhs.player) || (lhs.player && rhs.player && *lhs.player == *rhs.player));
}

inline bool operator!=(const SC_CreatePlayer_FBS &lhs, const SC_CreatePlayer_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_CreatePlayer_FBS::SC_CreatePlayer_FBS(const SC_CreatePlayer_FBS &o)
      : player((o.player) ? new NetworkMessage::CreatePlayerInfo_FBS(*o.player) : nullptr) {
}

inline SC_CreatePlayer_FBS &SC_CreatePlayer_FBS::operator=(SC_CreatePlayer_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(player, o.player);
  return *this;
}

inline SC_CreatePlayer_FBS *SC_CreatePlayer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_CreatePlayer_FBS>(new SC_CreatePlayer_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_CreatePlayer::UnPackTo(SC_CreatePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player(); if (_e) { if(_o->player) { _e->UnPackTo(_o->player.get(), _resolver); } else { _o->player = std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS>(_e->UnPack(_resolver)); } } else if (_o->player) { _o->player.reset(); } }
}

inline ::flatbuffers::Offset<SC_CreatePlayer> SC_CreatePlayer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_CreatePlayer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_CreatePlayer> CreateSC_CreatePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_CreatePlayer_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player = _o->player ? CreateCreatePlayerInfo(_fbb, _o->player.get(), _rehasher) : 0;
  return NetworkMessage::CreateSC_CreatePlayer(
      _fbb,
      _player);
}


inline bool operator==(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs) {
  return
      (lhs.player.size() == rhs.player.size() && std::equal(lhs.player.cbegin(), lhs.player.cend(), rhs.player.cbegin(), [](std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS> const &a, std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const SC_CreatePlayers_FBS &lhs, const SC_CreatePlayers_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_CreatePlayers_FBS::SC_CreatePlayers_FBS(const SC_CreatePlayers_FBS &o) {
  player.reserve(o.player.size());
  for (const auto &player_ : o.player) { player.emplace_back((player_) ? new NetworkMessage::CreatePlayerInfo_FBS(*player_) : nullptr); }
}

inline SC_CreatePlayers_FBS &SC_CreatePlayers_FBS::operator=(SC_CreatePlayers_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(player, o.player);
  return *this;
}

inline SC_CreatePlayers_FBS *SC_CreatePlayers::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_CreatePlayers_FBS>(new SC_CreatePlayers_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_CreatePlayers::UnPackTo(SC_CreatePlayers_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player(); if (_e) { _o->player.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->player[_i]) { _e->Get(_i)->UnPackTo(_o->player[_i].get(), _resolver); } else { _o->player[_i] = std::shared_ptr<NetworkMessage::CreatePlayerInfo_FBS>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->player.resize(0); } }
}

inline ::flatbuffers::Offset<SC_CreatePlayers> SC_CreatePlayers::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_CreatePlayers(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_CreatePlayers> CreateSC_CreatePlayers(::flatbuffers::FlatBufferBuilder &_fbb, const SC_CreatePlayers_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_CreatePlayers_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player = _fbb.CreateVector<::flatbuffers::Offset<NetworkMessage::CreatePlayerInfo>> (_o->player.size(), [](size_t i, _VectorArgs *__va) { return CreateCreatePlayerInfo(*__va->__fbb, __va->__o->player[i].get(), __va->__rehasher); }, &_va );
  return NetworkMessage::CreateSC_CreatePlayers(
      _fbb,
      _player);
}


inline bool operator==(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs) {
  return
      (lhs.sessionid == rhs.sessionid);
}

inline bool operator!=(const SC_RemovePlayer_FBS &lhs, const SC_RemovePlayer_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_RemovePlayer_FBS *SC_RemovePlayer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_RemovePlayer_FBS>(new SC_RemovePlayer_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_RemovePlayer::UnPackTo(SC_RemovePlayer_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionid(); _o->sessionid = _e; }
}

inline ::flatbuffers::Offset<SC_RemovePlayer> SC_RemovePlayer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_RemovePlayer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_RemovePlayer> CreateSC_RemovePlayer(::flatbuffers::FlatBufferBuilder &_fbb, const SC_RemovePlayer_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_RemovePlayer_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionid = _o->sessionid;
  return NetworkMessage::CreateSC_RemovePlayer(
      _fbb,
      _sessionid);
}


inline bool operator==(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs) {
  return
      (lhs.sessionid == rhs.sessionid) &&
      (lhs.head == rhs.head) &&
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position));
}

inline bool operator!=(const SC_UpdatePosition_FBS &lhs, const SC_UpdatePosition_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_UpdatePosition_FBS::SC_UpdatePosition_FBS(const SC_UpdatePosition_FBS &o)
      : sessionid(o.sessionid),
        head(o.head),
        position((o.position) ? new NetworkMessage::Vector3(*o.position) : nullptr) {
}

inline SC_UpdatePosition_FBS &SC_UpdatePosition_FBS::operator=(SC_UpdatePosition_FBS o) FLATBUFFERS_NOEXCEPT {
  std::swap(sessionid, o.sessionid);
  std::swap(head, o.head);
  std::swap(position, o.position);
  return *this;
}

inline SC_UpdatePosition_FBS *SC_UpdatePosition::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_UpdatePosition_FBS>(new SC_UpdatePosition_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_UpdatePosition::UnPackTo(SC_UpdatePosition_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sessionid(); _o->sessionid = _e; }
  { auto _e = head(); _o->head = _e; }
  { auto _e = position(); if (_e) _o->position = std::shared_ptr<NetworkMessage::Vector3>(new NetworkMessage::Vector3(*_e)); }
}

inline ::flatbuffers::Offset<SC_UpdatePosition> SC_UpdatePosition::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_UpdatePosition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_UpdatePosition> CreateSC_UpdatePosition(::flatbuffers::FlatBufferBuilder &_fbb, const SC_UpdatePosition_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_UpdatePosition_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sessionid = _o->sessionid;
  auto _head = _o->head;
  auto _position = _o->position ? _o->position.get() : nullptr;
  return NetworkMessage::CreateSC_UpdatePosition(
      _fbb,
      _sessionid,
      _head,
      _position);
}


inline bool operator==(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs) {
  return
      (lhs.head == rhs.head) &&
      (lhs.health == rhs.health) &&
      (lhs.state == rhs.state);
}

inline bool operator!=(const SC_PlayerUpdate_FBS &lhs, const SC_PlayerUpdate_FBS &rhs) {
    return !(lhs == rhs);
}


inline SC_PlayerUpdate_FBS *SC_PlayerUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SC_PlayerUpdate_FBS>(new SC_PlayerUpdate_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SC_PlayerUpdate::UnPackTo(SC_PlayerUpdate_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = head(); _o->head = _e; }
  { auto _e = health(); _o->health = _e; }
  { auto _e = state(); _o->state = _e; }
}

inline ::flatbuffers::Offset<SC_PlayerUpdate> SC_PlayerUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSC_PlayerUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SC_PlayerUpdate> CreateSC_PlayerUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const SC_PlayerUpdate_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SC_PlayerUpdate_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _head = _o->head;
  auto _health = _o->health;
  auto _state = _o->state;
  return NetworkMessage::CreateSC_PlayerUpdate(
      _fbb,
      _head,
      _health,
      _state);
}


inline bool operator==(const PacketWrapper_FBS &lhs, const PacketWrapper_FBS &rhs) {
  return
      (lhs.type == rhs.type) &&
      (lhs.packet == rhs.packet);
}

inline bool operator!=(const PacketWrapper_FBS &lhs, const PacketWrapper_FBS &rhs) {
    return !(lhs == rhs);
}


inline PacketWrapper_FBS *PacketWrapper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PacketWrapper_FBS>(new PacketWrapper_FBS());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PacketWrapper::UnPackTo(PacketWrapper_FBS *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = packet(); if (_e) { _o->packet.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->packet.begin()); } }
}

inline ::flatbuffers::Offset<PacketWrapper> PacketWrapper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PacketWrapper_FBS* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePacketWrapper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PacketWrapper> CreatePacketWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const PacketWrapper_FBS *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PacketWrapper_FBS* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _packet = _fbb.CreateVector(_o->packet);
  return NetworkMessage::CreatePacketWrapper(
      _fbb,
      _type,
      _packet);
}

inline const NetworkMessage::PacketWrapper *GetPacketWrapper(const void *buf) {
  return ::flatbuffers::GetRoot<NetworkMessage::PacketWrapper>(buf);
}

inline const NetworkMessage::PacketWrapper *GetSizePrefixedPacketWrapper(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NetworkMessage::PacketWrapper>(buf);
}

inline bool VerifyPacketWrapperBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NetworkMessage::PacketWrapper>(nullptr);
}

inline bool VerifySizePrefixedPacketWrapperBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NetworkMessage::PacketWrapper>(nullptr);
}

inline void FinishPacketWrapperBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NetworkMessage::PacketWrapper> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPacketWrapperBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NetworkMessage::PacketWrapper> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::shared_ptr<NetworkMessage::PacketWrapper_FBS> UnPackPacketWrapper(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::shared_ptr<NetworkMessage::PacketWrapper_FBS>(GetPacketWrapper(buf)->UnPack(res));
}

inline std::shared_ptr<NetworkMessage::PacketWrapper_FBS> UnPackSizePrefixedPacketWrapper(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::shared_ptr<NetworkMessage::PacketWrapper_FBS>(GetSizePrefixedPacketWrapper(buf)->UnPack(res));
}

}  // namespace NetworkMessage

#endif  // FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKMESSAGE_H_
